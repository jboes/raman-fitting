* Peak fitting code

[[./rplot.png]]

[[./ramanplot.png]]

#+BEGIN_SRC python
import numpy as np
import matplotlib.pyplot as plt
from scipy.special import erf
from scipy.optimize import curve_fit
import os

# Put the name of your data file here
data_file_name = ['rawdata.txt']

# Indicate which file you would like to fit too:
dfile = 0

# IMPORTANT: This needs to be set to whichever fitting step you are working on
# step = 1: Fittings the baseline
# step = 2: Choosing initial guess for peaks
# step = 3: Evaluate the fit
# step = 4: View and save the final figure
step = 4
output = True

# Step 1
# Choose the intensities to include in the base line fit
# Values < low and > high are included
low, high = 360,   675

# Step 2
# These are initial guesses of thetunning parameters for the Gaussian fits.
#    Peak #:   1     2
parguess = (   475,  557,        # Peak center
               50,   100,        # Amplitude of peak 1
               50,   60,         # Amplitude of peak 2
               10,   5,          # Standard deviation of peak 1
               10,   5)          # Standard deviation of peak 2


# ---------- NOTHING BELOW THIS LINE SHOULD NEED TO BE CHANGED -------------------
# This unpacks the data from the text file.
S,I = np.loadtxt(data_file_name[dfile], usecols=(0,1), unpack=True)

# Seperate the data points to be used for fitting the baseline
xbl = np.append(S[(S < low)],S[(S > high)])
ybl = np.append(I[(S < low)],I[(S > high)])

# Fits a line to the base line points
blpars = np.polyfit(xbl,ybl,1)
blfit = np.poly1d(blpars)

if step != 1 and step != 2 and step != 3 and step != 4:
    print 'Set step = 1,2 or 3 to continue'

# Step 1: Choose low and high values for a satisfactory baseline
if step == 1:
    plt.figure()
    plt.plot(S, I, label='data')
    plt.plot(S, blfit(S),'r-',lw=2, label='base line')
    plt.xlabel('Raman shift (cm$^{-1}$)')
    plt.ylabel('Intensity (counts)')
    plt.legend(loc='best')
    plt.show()
    print 'When you are satisfied with the fit of the base line, set step = 2'
    exit()

# Subtracts the baseline from the intensities
I -= blfit(S)

# Gaussians will only be fit the the data now used for the baseline
nS = S[(S > low) & (S < high)]
nI = I[(S > low) & (S < high)]

# These are functions which define the types of fit which you could implement
# Currently, the code only utilizes gaussians, but we can make other options available if necessary
# ----------------------------------------------------------------------
def gaussian(x, pars):
    A = pars[0]    # amplitude
    mu = pars[1]   # means
    sig = pars[2]  # std dev
    return A * np.exp((-(x - mu)**2.) / ((2*sig)**2.))

def sum_gaussian(x, *p):    
    g1 = gaussian(x, [p[2], p[0], p[6]])
    g2 = gaussian(x, [p[3], p[0], p[7]])
    g3 = gaussian(x, [p[4], p[1], p[8]])
    g4 = gaussian(x, [p[5], p[1], p[9]])
    return g1 + g2 + g3 + g4
# ----------------------------------------------------------------------

# Step 2: Fitting the curves to the data
if step == 2:
    plt.figure()
    plt.plot(nS, nI,'b-',label='Data')
    plt.plot(S,sum_gaussian(S, *parguess),'g--',lw=3,label='Initial guess')
    plt.xlim(low,high)
    plt.ylim(0,max(nI)+2)
    plt.xlabel('Raman shift (cm$^{-1}$)')
    plt.ylabel('Intensity (counts)')
    plt.legend(loc='best')
    plt.show()
    print 'Once the initial guess looks reasonable, set step = 3'
    exit()

# This is a multivaraible curve fitting program which attempts to optimize the fitting parameters
popt, pcov = curve_fit(sum_gaussian, S, I, parguess)

peak1 = gaussian(S, [popt[2],popt[0],popt[6]]) + gaussian(S, [popt[3],popt[0],popt[7]])
peak2 = gaussian(S, [popt[4],popt[1],popt[8]]) + gaussian(S, [popt[5],popt[1],popt[9]])

# Step 3: Evaluate the fit
if step == 3:
    plt.figure()
    plt.plot(nS, nI,'b-',label='Data')
    plt.plot(S,sum_gaussian(S, *popt),'r-',lw=3,label='Final Fit')
    plt.plot(S,peak1,'m-',lw=3,label='Fit for peak 1')
    plt.plot(S,gaussian(S, [popt[4],popt[1],popt[8]])+gaussian(S, [popt[5],popt[1],popt[9]]),'c-',lw=3,label='Fit for peak 2')
    plt.xlim(low,high)
    plt.ylim(0,max(nI)+2)
    plt.xlabel('Raman shift (cm$^{-1}$)')
    plt.ylabel('Intensity (counts)')
    plt.legend(loc='best')
    plt.show()
    print 'When you are satisfied with the peak fit, set step = 3'
    print 'else, return to step 2 and choose new fitting parameters'
    exit()

# Step 4: A summary of the resulting fit
if step == 4:
    ypeak1 = popt[2]+popt[3]+blfit(popt[0])
    ypeak2 = popt[4]+popt[5]+blfit(popt[1])

    area1 = -np.trapz(S, peak1)
    area2 = -np.trapz(S, peak2)

    savefile = data_file_name[dfile].strip('.txt')
    
    plt.figure()
    plt.plot(S, I + blfit(S),label='data')
    plt.plot(S,sum_gaussian(S, *popt) + blfit(S),'r-',lw=3,label='fit')

    # Annotation code is choppy and doesnt print legibly on large figures, to be fixed
    #plt.annotate('Peak 1', xy=(popt[0],ypeak1), xytext=(parguess[0]-25, blfit(popt[1])-1))
    #plt.annotate('Peak 2', xy=(popt[1],ypeak2), xytext=(parguess[1]-25, blfit(popt[1])-1))
    #plt.annotate('Mean = {0:1.1f}'.format(popt[0]), xy=(popt[0],ypeak1), xytext=(parguess[0]-25, blfit(popt[1])-1.7))
    #plt.annotate('Mean = {0:1.1f}'.format(popt[1]), xy=(popt[1],ypeak2), xytext=(parguess[1]-25, blfit(popt[1])-1.7))
    #plt.annotate('Area = {0:1.1f}'.format(area1), xy=(popt[0],ypeak1), xytext=(parguess[0]-25, blfit(popt[1])-2.4))
    #plt.annotate('Area = {0:1.1f}'.format(area2), xy=(popt[1],ypeak2), xytext=(parguess[1]-25, blfit(popt[1])-2.4))
    #plt.annotate('Height = {0:1.1f}'.format(ypeak1), xy=(popt[0],ypeak1), xytext=(parguess[0]-25, blfit(popt[1])-3.1))
    #plt.annotate('Height = {0:1.1f}'.format(ypeak2), xy=(popt[1],ypeak2), xytext=(parguess[1]-25, blfit(popt[1])-3.1))

    plt.xlabel('Raman shift (cm$^{-1}$)')
    plt.ylabel('Intensity (counts)')
    plt.savefig(savefile + '.png')
    plt.show()

    print 'Results'
    print '======='
    print 'Mean = {0:1.1f}'.format(popt[0])
    print 'Mean = {0:1.1f}'.format(popt[1])

    print 'Area = {0:1.1f}'.format(area1)
    print 'Area = {0:1.1f}'.format(area2)

    print 'Height = {0:1.1f}'.format(ypeak1)
    print 'Height = {0:1.1f}'.format(ypeak2)

    if output:
        filename = data_file_name[dfile].strip('.txt') + '.fit'

        dn = ''
        bln = ''
        for parameter in popt:
            dn += '{0} '.format(parameter)
        for parameter in blpars:
            bln += '{0} '.format(parameter)

        f = open(filename,'w')
        f.write(dn+'\n')
        f.write(bln)
        f.close()
#+END_SRC

#+RESULTS:
: Results
: =======
: Mean = 481.4
: Mean = 562.3
: Area = 4650.3
: Area = 4555.0
: Height = 154.4
: Height = 113.2

* Multiple fit plotting

[[./combined-plot.png]]

#+BEGIN_SRC python
import numpy as np
import matplotlib.pyplot as plt
import os

# Put the name of your data files here
data_file_name = ['john-data/Ni-Li-2-Fefree-Raman-750mV-07-24-14.txt',
                  'john-data/Ni-Li-3-Fefree-Raman-750mV-07-24-14.txt',
                  'john-data/Ni-Cs-2-Fefree-Raman-750mV-07-24-14.txt',
                  'john-data/Ni-Cs-1-Fefree-Raman-750mV-07-24-14.txt']

def Gaussian(x, pars):
    A = pars[0]    # amplitude
    mu = pars[1]   # means
    sig = pars[2]  # std dev
    return A * np.exp((-(x - mu)**2.) / ((2*sig)**2.))

def sum_gaussian(x, pars):
    p = pars
    g1 = Gaussian(x, [p[2], p[0], p[6]])
    g2 = Gaussian(x, [p[3], p[0], p[7]])
    g3 = Gaussian(x, [p[4], p[1], p[8]])
    g4 = Gaussian(x, [p[5], p[1], p[9]])
    return g1 + g2 + g3 + g4

# Extracts peak data and fit data
Sig,I,par,bl = [],[],[],[]
for f in data_file_name:
    signal,intensity = np.loadtxt(f, usecols=(0,1), unpack=True)
    Sig.append(signal)
    I.append(intensity)

    fit_file_name = f.strip('.txt') + '.fit'
    
    fitdata = open(fit_file_name,'r')

    gaussian = fitdata.readline().split()
    par.append(np.array(map(float, gaussian)))

    baseline = fitdata.readline().split()
    bl.append(np.poly1d(map(float, baseline)))
    fitdata.close()

offset = [0,0,70,80]
cl = ['b','b','g','g']

for i,S in enumerate(Sig):
 
    plt.plot(S, I[i]+offset[i],color=cl[i])
    plt.plot(S,sum_gaussian(S, par[i])+bl[i](S)+offset[i],'r-')

plt.text(Sig[1][-1]-5,I[1][-1]+offset[1]+5,'LiOH',horizontalalignment='right',verticalalignment='bottom')
plt.text(Sig[3][-1]-5,I[3][-1]+offset[3]+12,'CsOH',horizontalalignment='right',verticalalignment='bottom')

# EDIT THIS TO SHIFT THE POSITON OF THE INDICATOR LINES
# par[0][0] and par[0][1] are the centers of peak 1 and 2 for the first curve (closest to bottom)
# par[1][0] and par[1][1] are the centers of peak 1 and 2 for the second curve (next closest to bottom)
# etc...
peak1,peak2 = par[0][0], par[0][1] # cm^-1


plt.plot([peak1,peak1],[0,300],'k-')
plt.plot([peak2,peak2],[0,300],'k-')

plt.xlim(250,750)
plt.ylim(0,300)
plt.xlabel('Raman shift (cm$^{-1}$)')
plt.ylabel('Intensity (counts)')
plt.savefig('combined-plot.png')
plt.show()
#+END_SRC
